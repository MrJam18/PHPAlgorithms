2.1. Если ключ строковый — то происходит хеширование строки до integer-a (используется алгоритм хеширования DJBX33A):
   - Первоначальное значение хеша взято за магические 5381
   - На каждый символ ключа умножаем хеш на 33 и прибавляем номер символа по ASCII.
   Возьмем вышеуказанную операцию за 1 операцию. На полученый числовой ключ накладывается маска (bitwise and), которая всегда равна размеру массива (который с ведрами) минус 1. Также 1 операция. В итоге этот ключ можно использовать как индекс, чтобы вытащить нужный указатель на Bucket из массива. Если значение не является объектом или массивом и передано не по ссылке, а по значению, то также значение копируется в переменную из массива. Также одна операция.
   Таким образом, сложность получения элемента из массива для строковых ключей - O(3n), для числовых ключей - O(2n).
2.2. O(2n + 1)  - + 1, так как сначала создается массив - 1 операция. 2 * n, так как сначала он берет массив и копирует каждый элемент это 1 * n, а потом каждый элемент копирует в новый массив. n - количество элементов массива.

2.3. function fact($n  = 4) {
         if ($n <= 0) return 1;
         return $n * fact ($n-1);
     }
     O((f*n + 1) + (f * n)), где f - это значение переменной $n в функции, а n - количество операций факториала. Так как сравнение будет работать с нулем, то сравнений будет больше на 1 операцию, чем значение переменной $n, а операций умножения столько, сколько и число факториала.
3.1. для первого цикла - 100 итераций, для 2 цикла - 6 итераций 100 раз - 600 итераций.  сложность - 3(определение переменных $n, $array, $i) + 100(увеличение переменной $i) + 101(сравнение переменных) + (7(определение и переопределение $j) + 7(сравнение переменных $n, $j)) * 100;
3.2. для первого цикла - 50 итераций, для второго - 2550. Сложность O(n((f/2)² + f/2)), где f - это переменная $n.